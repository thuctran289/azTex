{"name":"aztex","tagline":"AZimpler Text editor. ","body":"Project Proposal\r\n================\r\n\r\n### Big Ideas\r\nThe big idea for our project will be to make a program that will emulate\r\nLaTex, only simpler and easier to pick up. The program name will be called aztex.\r\nThe program will take a text file that is in aztex format, and convert it into a\r\nnicely formatted pdf document.\r\nThe minimum viable product for our project is a program that takes a text\r\nfile with minimal formatting and converts it into a professional pdf using the\r\nlatex compiler. \r\nThe following features are highly desired:\r\n\r\n1. Numbered Lists\r\n2. Unordered Lists\r\n3. Headers\r\n4. Links\r\n5. Bold, italic, underline, strike-through\r\n\r\nSome stretch goals that may be pursued are programming our own pdf\r\ncompiler, integrated gui to see how the documents will be formatted, and adding\r\nfurther features like images and such.\r\n\r\n### Learning Goals\r\nShared:\r\n\r\n1. Learn more about parsing documents\r\n2. Learn more about working in project teams\r\n3. Interfacing with other libraries.\r\n\r\nIndividual:\r\n\r\nJordan Van Duyne:\r\n\r\n1. Make more in-line comments\r\n2. Test more often\r\n\r\nThuc Tran:\r\n\r\n1. Develop better unit tests.\r\n2. Write more efficient code -> Use less nested for loops.\r\n\r\nIsaac Getto:\r\n\r\n1. Write more tests\r\n2. Organize code better\r\n\r\n### Implementation Plan\r\n1. Find latex compiling library\r\n2. Determine how to simplify LaTeX language\r\na. Develop our own language based off of simplified LaTex\r\n3. Learn how to parse our language\r\n4. Separate projects into components -> i.e. compiling, parsing, processing\r\n5. Develop our own compiler\r\n\r\n\r\n### Project Schedule\r\nWeekly Goals:\r\n\r\n1. Figure out the program architecture (with UML/diagrams)\r\n2. Create our language (unit tests for individual formatting options)\r\n3. Working on parsing text file into intermediate representation.\r\n4. Processing intermediate into LaTex Format\r\n5. Compile the intermediate into a PDF\r\n6. Stretch Goals + Debugging.\r\n\r\n\r\n### Collaboration Plan\r\nOverall plan is to work collaboratively on the program architecture and\r\ndeveloping the simplified language. This is to make sure that we are all on the\r\nsame page for what kind of implementation on which we will be working. After\r\nwhich we will subdivide parts of the parsing, processing, and compiling when we\r\nhave functions and subfunctions that do not interact with each other directly.\r\nThis will let us work in parallel for sections of the project.\r\n\r\n### Risks\r\n\r\n- The project could be more complex than we thought\r\n- Libraries are non-existent or difficult to work with.\r\n- Unexpected lack of free work time.\r\n\r\n###Additional Course Content\r\n- language processing\r\n\r\n\r\nPreparation and Framing Document\r\n================================\r\n\r\n###The big idea\r\n\r\nMaking a LaTex that is simpler to use.\r\n\r\nHow?\r\n\r\nInstead of latex style, use markdown style\r\n\r\nWhat is markdown?\r\n\r\nhttp://en.wikipedia.org/wiki/Markdown#Example\r\n\r\n###Formatting that we want to include:\r\n\r\n- Math symbols\r\n- Lists (ordered and unordered)\r\n- Size of text\r\n- Bold, underline, strikethrough, italics\r\n- Title\r\n- Headers\r\n\r\nThe goal is for teachers to be able to make (math) homework documents with it\r\n\r\nHave user input simple code, which our program turns into the analogous latex code.\r\n\r\nWe then input this latex code into a latex compiler using the PyLaTeX library: https://github.com/JelteF/PyLaTeX \r\n\r\n###General compiler architecture\r\n\r\nEffectively, the task is to compile a LaTex language in another (new) language.\r\n\r\nGenerally a compiler will have a front end, middle end, back end.\r\n\r\n- The front end will focus on converting user input into some intermediate form.\r\n\r\n- The middle end will generally optimize code so one gets rid of extraneous/unreachable code, and other tricks. This will be seen more often in writing programs, rather than text. We may not end up doing some of this.\r\n\r\n- The back end will focus on converting the intermediate representation into the needed LaTex code, and then compiling the code. \r\n\r\n\r\nWhy would we not have a middle end?\r\n\r\n- We don't necessarily want to optimize the code due to the fact that we want to represent the user intentions as accurately as possible.\r\n\r\n###Key Questions\r\n\r\n1. How do we want to represent each character? \r\n2. Should attributes like underlining and bolding be its own class/token or should it be part of a text class?\r\n3. How are the parts (tokenizer and parser) connected?\r\n4. Is it parsed all at once or token by token?\r\n5. As a stream or with files?\r\n6. Do we need a middle end?\r\n7. How can we make the language simpler for users? Give context of math teacher\r\n8. Do we want a gui?\r\n9. How do we make the language simpler for us? Easier to parse\r\n10. Should the final outputted pdf document be able to be formatted with an option of different themes?\r\nE.g. a math theme, note-taking theme, etc. \r\n11. Should we have users type in our program? If not, what text format do we want to use? .txt? .doc?\r\n\r\n###Agenda for technical review session\r\n\r\nThe beginning will mostly be under a std. powerpoint presentation of information. \r\n\r\n- 2 Minutes on what we want out of the review: affirmation that we’re on the right track and feedback on our key questions\r\n- 1 Minute: Who are we? What are we doing?\r\n- 5 Minutes: Background context with PPT\r\n- 3 Minutes: How we’re structuring the system + UML\r\n- Until we get kicked off: QUESTION SLIDES\r\n\r\nThis will mostly be done in a conversational, “Here is our question, here are some thoughts, help us”\r\n\r\n###The main questions to be addressed at the review:\r\n\r\n1. Are elementary school math teachers an appropriate target audience? Any other ideas for possible audiences?\r\n2. How are the parts of the program connected (tokenizer, parser)? Are tokens sent to the parser one by one, or all together?\r\n3. How should we set up the language itself?\r\n4. How can it be easy for the user?\r\n5. How can it be easy for us to parse?\r\n6. How do you think we might want to store our intermediate representation?\r\n7. Should it be a class for each attribute? Or should attributes be under a class?\r\n8. Do we need a middle end?\r\n9. Any concerns y’all have?\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}