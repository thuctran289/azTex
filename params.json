{"name":"aztex","tagline":"AZimpler Text editor. ","body":"Project Proposal\r\n================\r\n\r\n### Big Ideas\r\nThe big idea for our project will be to make a program that will emulate\r\nLaTex, only simpler and easier to pick up. The program name will be called aztex.\r\nThe program will take a text file that is in aztex format, and convert it into a\r\nnicely formatted pdf document.\r\nThe minimum viable product for our project is a program that takes a text\r\nfile with minimal formatting and converts it into a professional pdf using the\r\nlatex compiler. \r\nThe following features are highly desired:\r\n\r\n1. Numbered Lists\r\n2. Unordered Lists\r\n3. Headers\r\n4. Links\r\n5. Bold, italic, underline, strike-through\r\n\r\nSome stretch goals that may be pursued are programming our own pdf\r\ncompiler, integrated gui to see how the documents will be formatted, and adding\r\nfurther features like images and such.\r\n\r\n### Learning Goals\r\nShared:\r\n\r\n1. Learn more about parsing documents\r\n2. Learn more about working in project teams\r\n3. Interfacing with other libraries.\r\n\r\nIndividual:\r\n\r\nJordan Van Duyne:\r\n\r\n1. Make more in-line comments\r\n2. Test more often\r\n\r\nThuc Tran:\r\n\r\n1. Develop better unit tests.\r\n2. Write more efficient code -> Use less nested for loops.\r\n\r\nIsaac Getto:\r\n\r\n1. Write more tests\r\n2. Organize code better\r\n\r\n### Implementation Plan\r\n1. Find latex compiling library\r\n2. Determine how to simplify LaTeX language\r\na. Develop our own language based off of simplified LaTex\r\n3. Learn how to parse our language\r\n4. Separate projects into components -> i.e. compiling, parsing, processing\r\n5. Develop our own compiler\r\n\r\n\r\n### Project Schedule\r\nWeekly Goals:\r\n\r\n1. Figure out the program architecture (with UML/diagrams)\r\n2. Create our language (unit tests for individual formatting options)\r\n3. Working on parsing text file into intermediate representation.\r\n4. Processing intermediate into LaTex Format\r\n5. Compile the intermediate into a PDF\r\n6. Stretch Goals + Debugging.\r\n\r\n\r\n### Collaboration Plan\r\nOverall plan is to work collaboratively on the program architecture and\r\ndeveloping the simplified language. This is to make sure that we are all on the\r\nsame page for what kind of implementation on which we will be working. After\r\nwhich we will subdivide parts of the parsing, processing, and compiling when we\r\nhave functions and subfunctions that do not interact with each other directly.\r\nThis will let us work in parallel for sections of the project.\r\n\r\n### Risks\r\n\r\n- The project could be more complex than we thought\r\n- Libraries are non-existent or difficult to work with.\r\n- Unexpected lack of free work time.\r\n\r\n###Additional Course Content\r\n- language processing\r\n\r\n\r\nPreparation and Framing Document\r\n================================\r\n\r\n###The big idea\r\n\r\nMaking a LaTex that is simpler to use.\r\n\r\nHow?\r\n\r\nInstead of latex style, use markdown style\r\n\r\nWhat is markdown?\r\n\r\nhttp://en.wikipedia.org/wiki/Markdown#Example\r\n\r\n###Formatting that we want to include:\r\n\r\n- Math symbols\r\n- Lists (ordered and unordered)\r\n- Size of text\r\n- Bold, underline, strikethrough, italics\r\n- Title\r\n- Headers\r\n\r\nThe goal is for teachers to be able to make (math) homework documents with it\r\n\r\nHave user input simple code, which our program turns into the analogous latex code.\r\n\r\nWe then input this latex code into a latex compiler using the PyLaTeX library: https://github.com/JelteF/PyLaTeX \r\n\r\n###General compiler architecture\r\n\r\nEffectively, the task is to compile a LaTex language in another (new) language.\r\n\r\nGenerally a compiler will have a front end, middle end, back end.\r\n\r\n- The front end will focus on converting user input into some intermediate form.\r\n\r\n- The middle end will generally optimize code so one gets rid of extraneous/unreachable code, and other tricks. This will be seen more often in writing programs, rather than text. We may not end up doing some of this.\r\n\r\n- The back end will focus on converting the intermediate representation into the needed LaTex code, and then compiling the code. \r\n\r\n\r\nWhy would we not have a middle end?\r\n\r\n- We don't necessarily want to optimize the code due to the fact that we want to represent the user intentions as accurately as possible.\r\n\r\n###Key Questions\r\n\r\n1. How do we want to represent each character? \r\n2. Should attributes like underlining and bolding be its own class/token or should it be part of a text class?\r\n3. How are the parts (tokenizer and parser) connected?\r\n4. Is it parsed all at once or token by token?\r\n5. As a stream or with files?\r\n6. Do we need a middle end?\r\n7. How can we make the language simpler for users? Give context of math teacher\r\n8. Do we want a gui?\r\n9. How do we make the language simpler for us? Easier to parse\r\n10. Should the final outputted pdf document be able to be formatted with an option of different themes?\r\nE.g. a math theme, note-taking theme, etc. \r\n11. Should we have users type in our program? If not, what text format do we want to use? .txt? .doc?\r\n\r\n###Agenda for technical review session\r\n\r\nThe beginning will mostly be under a std. powerpoint presentation of information. \r\n\r\n- 2 Minutes on what we want out of the review: affirmation that we’re on the right track and feedback on our key questions\r\n- 1 Minute: Who are we? What are we doing?\r\n- 5 Minutes: Background context with PPT\r\n- 3 Minutes: How we’re structuring the system + UML\r\n- Until we get kicked off: QUESTION SLIDES\r\n\r\nThis will mostly be done in a conversational, “Here is our question, here are some thoughts, help us”\r\n\r\n###The main questions to be addressed at the review:\r\n\r\n1. Are elementary school math teachers an appropriate target audience? Any other ideas for possible audiences?\r\n2. How are the parts of the program connected (tokenizer, parser)? Are tokens sent to the parser one by one, or all together?\r\n3. How should we set up the language itself?\r\n4. How can it be easy for the user?\r\n5. How can it be easy for us to parse?\r\n6. How do you think we might want to store our intermediate representation?\r\n7. Should it be a class for each attribute? Or should attributes be under a class?\r\n8. Do we need a middle end?\r\n9. Any concerns y’all have?\r\n\r\n##Design Review Reflection\r\n\r\n###Reflection and Synthesis\r\n\r\n\r\n####Feedback and decisions\r\n\r\nTeachers are not necessarily our key audience. In addition, we do want to manage the trade-off between simplicity and flexibility of our new language. There was also a discussion about a compromise between simplicity and flexibility via the use of a raw tag that lets you write LaTex code. \r\n\r\n####Going Forward:\r\n\t\r\nWe are most likely going to transition our target audience to students who are not familiar with LaTex. In particular, we may be focusing on either new students to Olin, or high school students in general. However, we have also decided that we can make design decisions based off of what we want out of our project, not necessarily what our “target audience” would want, since we are making this project for ourselves, not an audience. We may be focusing directly on using Markdown directly as a language. \r\n\r\n####New Questions:\r\n\r\nShould our program come with multiple example LaTeX templates?\r\nWhat features are most important for a student user?\r\nShould we use markdown as our exact language?\r\n\r\n\r\n###Review process reflection\r\n\r\n####How did the review go? \t\r\n\r\nIt went well. We got valuable feedback on how we want to think about our target audience going forward, and ideas for ways to implement the language and workflow of our program. \r\n\r\n####Did you get answers to your key questions?\r\n\r\nWe did get some feedback. In addition to transitioning to a new audience entirely as a result of feedback, the idea of balance between simplicity and complexity was brought up. We also received an answer to how we should structure our language: some adaptation of Markdown.\r\n\r\n####Did you provide too much/too little context for your audience? \r\n\t\t\r\nWe provided ample context for one of the technical aspects of our presentation (how compilers are usually split into a front, middle, and back end) in the reading we sent out before our Design Review, and as a result we only briefly addressed this specific background context in our presentation; we assumed our audience would have read the reading and thus be familiar with what we were talking about. However, no one actually read the reading, so as a result the small amount of context that we provided in our presentation was not enough for our audience to be able to answer the few technical questions that we had. However, besides this one small technical aspect of our presentation, we believe that we provided an appropriate amount of context for our audience.\r\n\r\n####Did you stick closely to your planned agenda, or did you discover new things during the discussion that made you change your plans? \r\n\r\nWe had stuck fairly closely to our overall agenda, but had found that certain questions we had got more response than others. In particular, for many of the more technical questions we had little feedback. This might be addressed by structuring the question as a function of different options or ideas that we are choosing from. \r\n\r\n####What could you do next time to have an even more effective technical review?\r\n\t\r\nFor our next presentation, we can change up our presentation style. For example, if we want our audience to help us generate ideas (such as design options), instead of just asking if the audience has any ideas, we could split the audience into smaller groups and have each group ideate for a few minutes and then bring all of the groups back together to look at all of the new ideas. We should also cover all of the background context that we provide in our pre-review readings in our presentation. We could frame our technical questions in a different way to give the audience more knowledge about the effects of different design options.\r\n\r\n\r\nCode Review\r\n===========\r\n\r\n##Preparation and Framing Document\r\n\r\n###Background and context\r\n\r\nWe are still working towards creating aztex: an easier to use version of LaTeX. However, we have decided that although we have pivoted our user group to be general students (with a focus on high school students or students who are not familiar with LaTeX), we will not be too concerned with creating aztex specifically for our user group. \r\n\r\naztex will work by compiling a txt file written using aztex language (similar to Markdown) into the analogous LaTeX code in order to output a pdf\r\n\r\nCompilers typically consist of a front, a middle, and a back end. \r\n\r\nThe front end consists of syntactic and semantic processing and translation of the source code to an internal representation.\r\n\r\nIn most compilers, the middle end optimizes the internal representation. However, due to the basicness that aztex has when compared to actual programming languages, we believe that a middle end is unnecessary for our aztex program.\r\n\r\nThe back end takes the internal representation and outputs code that a particular processor and OS can understand.\r\n\r\n####Our architecture:\r\n\r\nOur front end is consistent with standard compilers; it is made up of a parser and a tokenizer. We currently have finished most of the front end and classes that the front end implements, including:\r\n\r\n#####Tokenizer\r\n\r\nThe tokenizer uses a regular expression to look for two new lines in a row to find each block of text. The tokenizer will return tokens, block by block. \r\n\r\n#####Parser\r\n\r\nThe parser converts each token/block into a specific element object as defined below, depending on the type of token it is. The parser does this using via matching the string to the type of element via regular expression.\r\n\r\n#####Element\r\n\r\nElements represent the individual parts of the document. Eac part will be defined as a subclass of element such as HeadingElement or StrikeThroughElement, . They both possess the type of element they are, and any subelements the element type may apply to (i.e. bolding, or heading)\r\n\r\n#####InternalRepresentation\r\n\r\nThe InternalRepresentation class represents the structure of the document in terms of a list of Element objects. This will be program’s internal representation of the document. \r\nAlso consistent with standard compilers, our back end will include the classes:\r\n\r\n#####GenericOutput: \r\n\r\nThis will be an abstract class that contains handles that children classes such as LatexOutput or other languages can use.\r\n#####LatexOutput:\r\n\r\nLatexOutput will be a subclass of GenericOutput. We are still deciding the exact implementation of this class. Currently we are debating having this be an interface to a library vs. writing our own library for our code. \r\n\r\nIn order to possibly expand aztex beyond just a LaTeX document creator in the future, to assist in the ease of debugging, and to make parts of our code interchangeable, we have made sure to encapsulate our data and to practice modular programming. Basically, this means that, for example, the details of the Element class are “hidden” from the InternalRepresentation creator. \r\n\r\n####Key questions\r\n1. Should we use a library or an interface?\r\n2. Any edge cases we may not have seen?\r\n3. Any concerns that y’all foresee?\r\n4. Should we try to implement a GUI for the input?\r\n\r\n####Agenda for technical review section\r\n\r\n- 1 minute - Introduction and extremely high level description of aztex\r\n- 3 minutes - Provide background and context and explain what we have completed (front end).\r\n- 3 minutes - Code architecture description (UML diagram and explaining why we made sure to practice modular programming)\r\n- 5 minutes - Walk through code on a higher level.\r\n- 10 minutes - Have everyone clone our repository, run AztexRunner.py with an input of a text file written in our aztex language. This will help the audience gain a better understanding of our program and will also help us to see if our code does not work given any certain inputs. Since people will be inputting a text file that they create, they might create and test a certain input that we had not already tested. This will help us see possible edge cases that we may have overlooked. \r\n- 3 minutes - Key questions\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}