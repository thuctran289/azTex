<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>aztex by thuctran289</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='http://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">aztex</h1>
      <h2 class="project-tagline">AZimpler Text editor. </h2>
      <a href="https://github.com/thuctran289/aztex" class="btn">View on GitHub</a>
      <a href="https://github.com/thuctran289/aztex/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/thuctran289/aztex/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="project-proposal" class="anchor" href="#project-proposal" aria-hidden="true"><span class="octicon octicon-link"></span></a>Project Proposal</h1>

<h3>
<a id="big-ideas" class="anchor" href="#big-ideas" aria-hidden="true"><span class="octicon octicon-link"></span></a>Big Ideas</h3>

<p>The big idea for our project will be to make a program that will emulate
LaTex, only simpler and easier to pick up. The program name will be called aztex.
The program will take a text file that is in aztex format, and convert it into a
nicely formatted pdf document.
The minimum viable product for our project is a program that takes a text
file with minimal formatting and converts it into a professional pdf using the
latex compiler. 
The following features are highly desired:</p>

<ol>
<li>Numbered Lists</li>
<li>Unordered Lists</li>
<li>Headers</li>
<li>Links</li>
<li>Bold, italic, underline, strike-through</li>
</ol>

<p>Some stretch goals that may be pursued are programming our own pdf
compiler, integrated gui to see how the documents will be formatted, and adding
further features like images and such.</p>

<h3>
<a id="learning-goals" class="anchor" href="#learning-goals" aria-hidden="true"><span class="octicon octicon-link"></span></a>Learning Goals</h3>

<p>Shared:</p>

<ol>
<li>Learn more about parsing documents</li>
<li>Learn more about working in project teams</li>
<li>Interfacing with other libraries.</li>
</ol>

<p>Individual:</p>

<p>Jordan Van Duyne:</p>

<ol>
<li>Make more in-line comments</li>
<li>Test more often</li>
</ol>

<p>Thuc Tran:</p>

<ol>
<li>Develop better unit tests.</li>
<li>Write more efficient code -&gt; Use less nested for loops.</li>
</ol>

<p>Isaac Getto:</p>

<ol>
<li>Write more tests</li>
<li>Organize code better</li>
</ol>

<h3>
<a id="implementation-plan" class="anchor" href="#implementation-plan" aria-hidden="true"><span class="octicon octicon-link"></span></a>Implementation Plan</h3>

<ol>
<li>Find latex compiling library</li>
<li>Determine how to simplify LaTeX language
a. Develop our own language based off of simplified LaTex</li>
<li>Learn how to parse our language</li>
<li>Separate projects into components -&gt; i.e. compiling, parsing, processing</li>
<li>Develop our own compiler</li>
</ol>

<h3>
<a id="project-schedule" class="anchor" href="#project-schedule" aria-hidden="true"><span class="octicon octicon-link"></span></a>Project Schedule</h3>

<p>Weekly Goals:</p>

<ol>
<li>Figure out the program architecture (with UML/diagrams)</li>
<li>Create our language (unit tests for individual formatting options)</li>
<li>Working on parsing text file into intermediate representation.</li>
<li>Processing intermediate into LaTex Format</li>
<li>Compile the intermediate into a PDF</li>
<li>Stretch Goals + Debugging.</li>
</ol>

<h3>
<a id="collaboration-plan" class="anchor" href="#collaboration-plan" aria-hidden="true"><span class="octicon octicon-link"></span></a>Collaboration Plan</h3>

<p>Overall plan is to work collaboratively on the program architecture and
developing the simplified language. This is to make sure that we are all on the
same page for what kind of implementation on which we will be working. After
which we will subdivide parts of the parsing, processing, and compiling when we
have functions and subfunctions that do not interact with each other directly.
This will let us work in parallel for sections of the project.</p>

<h3>
<a id="risks" class="anchor" href="#risks" aria-hidden="true"><span class="octicon octicon-link"></span></a>Risks</h3>

<ul>
<li>The project could be more complex than we thought</li>
<li>Libraries are non-existent or difficult to work with.</li>
<li>Unexpected lack of free work time.</li>
</ul>

<h3>
<a id="additional-course-content" class="anchor" href="#additional-course-content" aria-hidden="true"><span class="octicon octicon-link"></span></a>Additional Course Content</h3>

<ul>
<li>language processing</li>
</ul>

<h1>
<a id="preparation-and-framing-document" class="anchor" href="#preparation-and-framing-document" aria-hidden="true"><span class="octicon octicon-link"></span></a>Preparation and Framing Document</h1>

<h3>
<a id="the-big-idea" class="anchor" href="#the-big-idea" aria-hidden="true"><span class="octicon octicon-link"></span></a>The big idea</h3>

<p>Making a LaTex that is simpler to use.</p>

<p>How?</p>

<p>Instead of latex style, use markdown style</p>

<p>What is markdown?</p>

<p><a href="http://en.wikipedia.org/wiki/Markdown#Example">http://en.wikipedia.org/wiki/Markdown#Example</a></p>

<h3>
<a id="formatting-that-we-want-to-include" class="anchor" href="#formatting-that-we-want-to-include" aria-hidden="true"><span class="octicon octicon-link"></span></a>Formatting that we want to include:</h3>

<ul>
<li>Math symbols</li>
<li>Lists (ordered and unordered)</li>
<li>Size of text</li>
<li>Bold, underline, strikethrough, italics</li>
<li>Title</li>
<li>Headers</li>
</ul>

<p>The goal is for teachers to be able to make (math) homework documents with it</p>

<p>Have user input simple code, which our program turns into the analogous latex code.</p>

<p>We then input this latex code into a latex compiler using the PyLaTeX library: <a href="https://github.com/JelteF/PyLaTeX">https://github.com/JelteF/PyLaTeX</a> </p>

<h3>
<a id="general-compiler-architecture" class="anchor" href="#general-compiler-architecture" aria-hidden="true"><span class="octicon octicon-link"></span></a>General compiler architecture</h3>

<p>Effectively, the task is to compile a LaTex language in another (new) language.</p>

<p>Generally a compiler will have a front end, middle end, back end.</p>

<ul>
<li><p>The front end will focus on converting user input into some intermediate form.</p></li>
<li><p>The middle end will generally optimize code so one gets rid of extraneous/unreachable code, and other tricks. This will be seen more often in writing programs, rather than text. We may not end up doing some of this.</p></li>
<li><p>The back end will focus on converting the intermediate representation into the needed LaTex code, and then compiling the code. </p></li>
</ul>

<p>Why would we not have a middle end?</p>

<ul>
<li>We don't necessarily want to optimize the code due to the fact that we want to represent the user intentions as accurately as possible.</li>
</ul>

<h3>
<a id="key-questions" class="anchor" href="#key-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Key Questions</h3>

<ol>
<li>How do we want to represent each character? </li>
<li>Should attributes like underlining and bolding be its own class/token or should it be part of a text class?</li>
<li>How are the parts (tokenizer and parser) connected?</li>
<li>Is it parsed all at once or token by token?</li>
<li>As a stream or with files?</li>
<li>Do we need a middle end?</li>
<li>How can we make the language simpler for users? Give context of math teacher</li>
<li>Do we want a gui?</li>
<li>How do we make the language simpler for us? Easier to parse</li>
<li>Should the final outputted pdf document be able to be formatted with an option of different themes?
E.g. a math theme, note-taking theme, etc. </li>
<li>Should we have users type in our program? If not, what text format do we want to use? .txt? .doc?</li>
</ol>

<h3>
<a id="agenda-for-technical-review-session" class="anchor" href="#agenda-for-technical-review-session" aria-hidden="true"><span class="octicon octicon-link"></span></a>Agenda for technical review session</h3>

<p>The beginning will mostly be under a std. powerpoint presentation of information. </p>

<ul>
<li>2 Minutes on what we want out of the review: affirmation that we’re on the right track and feedback on our key questions</li>
<li>1 Minute: Who are we? What are we doing?</li>
<li>5 Minutes: Background context with PPT</li>
<li>3 Minutes: How we’re structuring the system + UML</li>
<li>Until we get kicked off: QUESTION SLIDES</li>
</ul>

<p>This will mostly be done in a conversational, “Here is our question, here are some thoughts, help us”</p>

<h3>
<a id="the-main-questions-to-be-addressed-at-the-review" class="anchor" href="#the-main-questions-to-be-addressed-at-the-review" aria-hidden="true"><span class="octicon octicon-link"></span></a>The main questions to be addressed at the review:</h3>

<ol>
<li>Are elementary school math teachers an appropriate target audience? Any other ideas for possible audiences?</li>
<li>How are the parts of the program connected (tokenizer, parser)? Are tokens sent to the parser one by one, or all together?</li>
<li>How should we set up the language itself?</li>
<li>How can it be easy for the user?</li>
<li>How can it be easy for us to parse?</li>
<li>How do you think we might want to store our intermediate representation?</li>
<li>Should it be a class for each attribute? Or should attributes be under a class?</li>
<li>Do we need a middle end?</li>
<li>Any concerns y’all have?</li>
</ol>

<h2>
<a id="design-review-reflection" class="anchor" href="#design-review-reflection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Design Review Reflection</h2>

<h3>
<a id="reflection-and-synthesis" class="anchor" href="#reflection-and-synthesis" aria-hidden="true"><span class="octicon octicon-link"></span></a>Reflection and Synthesis</h3>

<h4>
<a id="feedback-and-decisions" class="anchor" href="#feedback-and-decisions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Feedback and decisions</h4>

<p>Teachers are not necessarily our key audience. In addition, we do want to manage the trade-off between simplicity and flexibility of our new language. There was also a discussion about a compromise between simplicity and flexibility via the use of a raw tag that lets you write LaTex code. </p>

<h4>
<a id="going-forward" class="anchor" href="#going-forward" aria-hidden="true"><span class="octicon octicon-link"></span></a>Going Forward:</h4>

<p>We are most likely going to transition our target audience to students who are not familiar with LaTex. In particular, we may be focusing on either new students to Olin, or high school students in general. However, we have also decided that we can make design decisions based off of what we want out of our project, not necessarily what our “target audience” would want, since we are making this project for ourselves, not an audience. We may be focusing directly on using Markdown directly as a language. </p>

<h4>
<a id="new-questions" class="anchor" href="#new-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>New Questions:</h4>

<p>Should our program come with multiple example LaTeX templates?
What features are most important for a student user?
Should we use markdown as our exact language?</p>

<h3>
<a id="review-process-reflection" class="anchor" href="#review-process-reflection" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review process reflection</h3>

<h4>
<a id="how-did-the-review-go" class="anchor" href="#how-did-the-review-go" aria-hidden="true"><span class="octicon octicon-link"></span></a>How did the review go?</h4>

<p>It went well. We got valuable feedback on how we want to think about our target audience going forward, and ideas for ways to implement the language and workflow of our program. </p>

<h4>
<a id="did-you-get-answers-to-your-key-questions" class="anchor" href="#did-you-get-answers-to-your-key-questions" aria-hidden="true"><span class="octicon octicon-link"></span></a>Did you get answers to your key questions?</h4>

<p>We did get some feedback. In addition to transitioning to a new audience entirely as a result of feedback, the idea of balance between simplicity and complexity was brought up. We also received an answer to how we should structure our language: some adaptation of Markdown.</p>

<h4>
<a id="did-you-provide-too-muchtoo-little-context-for-your-audience" class="anchor" href="#did-you-provide-too-muchtoo-little-context-for-your-audience" aria-hidden="true"><span class="octicon octicon-link"></span></a>Did you provide too much/too little context for your audience?</h4>

<p>We provided ample context for one of the technical aspects of our presentation (how compilers are usually split into a front, middle, and back end) in the reading we sent out before our Design Review, and as a result we only briefly addressed this specific background context in our presentation; we assumed our audience would have read the reading and thus be familiar with what we were talking about. However, no one actually read the reading, so as a result the small amount of context that we provided in our presentation was not enough for our audience to be able to answer the few technical questions that we had. However, besides this one small technical aspect of our presentation, we believe that we provided an appropriate amount of context for our audience.</p>

<h4>
<a id="did-you-stick-closely-to-your-planned-agenda-or-did-you-discover-new-things-during-the-discussion-that-made-you-change-your-plans" class="anchor" href="#did-you-stick-closely-to-your-planned-agenda-or-did-you-discover-new-things-during-the-discussion-that-made-you-change-your-plans" aria-hidden="true"><span class="octicon octicon-link"></span></a>Did you stick closely to your planned agenda, or did you discover new things during the discussion that made you change your plans?</h4>

<p>We had stuck fairly closely to our overall agenda, but had found that certain questions we had got more response than others. In particular, for many of the more technical questions we had little feedback. This might be addressed by structuring the question as a function of different options or ideas that we are choosing from. </p>

<h4>
<a id="what-could-you-do-next-time-to-have-an-even-more-effective-technical-review" class="anchor" href="#what-could-you-do-next-time-to-have-an-even-more-effective-technical-review" aria-hidden="true"><span class="octicon octicon-link"></span></a>What could you do next time to have an even more effective technical review?</h4>

<p>For our next presentation, we can change up our presentation style. For example, if we want our audience to help us generate ideas (such as design options), instead of just asking if the audience has any ideas, we could split the audience into smaller groups and have each group ideate for a few minutes and then bring all of the groups back together to look at all of the new ideas. We should also cover all of the background context that we provide in our pre-review readings in our presentation. We could frame our technical questions in a different way to give the audience more knowledge about the effects of different design options.</p>

<h1>
<a id="code-review" class="anchor" href="#code-review" aria-hidden="true"><span class="octicon octicon-link"></span></a>Code Review</h1>

<h2>
<a id="preparation-and-framing-document-1" class="anchor" href="#preparation-and-framing-document-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Preparation and Framing Document</h2>

<h3>
<a id="background-and-context" class="anchor" href="#background-and-context" aria-hidden="true"><span class="octicon octicon-link"></span></a>Background and context</h3>

<p>We are still working towards creating aztex: an easier to use version of LaTeX. However, we have decided that although we have pivoted our user group to be general students (with a focus on high school students or students who are not familiar with LaTeX), we will not be too concerned with creating aztex specifically for our user group. </p>

<p>aztex will work by compiling a txt file written using aztex language (similar to Markdown) into the analogous LaTeX code in order to output a pdf</p>

<p>Compilers typically consist of a front, a middle, and a back end. </p>

<p>The front end consists of syntactic and semantic processing and translation of the source code to an internal representation.</p>

<p>In most compilers, the middle end optimizes the internal representation. However, due to the basicness that aztex has when compared to actual programming languages, we believe that a middle end is unnecessary for our aztex program.</p>

<p>The back end takes the internal representation and outputs code that a particular processor and OS can understand.</p>

<h4>
<a id="our-architecture" class="anchor" href="#our-architecture" aria-hidden="true"><span class="octicon octicon-link"></span></a>Our architecture:</h4>

<p>Our front end is consistent with standard compilers; it is made up of a parser and a tokenizer. We currently have finished most of the front end and classes that the front end implements, including:</p>

<h5>
<a id="tokenizer" class="anchor" href="#tokenizer" aria-hidden="true"><span class="octicon octicon-link"></span></a>Tokenizer</h5>

<p>The tokenizer uses a regular expression to look for two new lines in a row to find each block of text. The tokenizer will return tokens, block by block. </p>

<h5>
<a id="parser" class="anchor" href="#parser" aria-hidden="true"><span class="octicon octicon-link"></span></a>Parser</h5>

<p>The parser converts each token/block into a specific element object as defined below, depending on the type of token it is. The parser does this using via matching the string to the type of element via regular expression.</p>

<h5>
<a id="element" class="anchor" href="#element" aria-hidden="true"><span class="octicon octicon-link"></span></a>Element</h5>

<p>Elements represent the individual parts of the document. Eac part will be defined as a subclass of element such as HeadingElement or StrikeThroughElement, . They both possess the type of element they are, and any subelements the element type may apply to (i.e. bolding, or heading)</p>

<h5>
<a id="internalrepresentation" class="anchor" href="#internalrepresentation" aria-hidden="true"><span class="octicon octicon-link"></span></a>InternalRepresentation</h5>

<p>The InternalRepresentation class represents the structure of the document in terms of a list of Element objects. This will be program’s internal representation of the document. 
Also consistent with standard compilers, our back end will include the classes:</p>

<h5>
<a id="genericoutput" class="anchor" href="#genericoutput" aria-hidden="true"><span class="octicon octicon-link"></span></a>GenericOutput:</h5>

<p>This will be an abstract class that contains handles that children classes such as LatexOutput or other languages can use.</p>

<h5>
<a id="latexoutput" class="anchor" href="#latexoutput" aria-hidden="true"><span class="octicon octicon-link"></span></a>LatexOutput:</h5>

<p>LatexOutput will be a subclass of GenericOutput. We are still deciding the exact implementation of this class. Currently we are debating having this be an interface to a library vs. writing our own library for our code. </p>

<p>In order to possibly expand aztex beyond just a LaTeX document creator in the future, to assist in the ease of debugging, and to make parts of our code interchangeable, we have made sure to encapsulate our data and to practice modular programming. Basically, this means that, for example, the details of the Element class are “hidden” from the InternalRepresentation creator. </p>

<h4>
<a id="key-questions-1" class="anchor" href="#key-questions-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Key questions</h4>

<ol>
<li>Should we use a library or an interface?</li>
<li>Any edge cases we may not have seen?</li>
<li>Any concerns that y’all foresee?</li>
<li>Should we try to implement a GUI for the input?</li>
</ol>

<h4>
<a id="agenda-for-technical-review-section" class="anchor" href="#agenda-for-technical-review-section" aria-hidden="true"><span class="octicon octicon-link"></span></a>Agenda for technical review section</h4>

<ul>
<li>1 minute - Introduction and extremely high level description of aztex</li>
<li>3 minutes - Provide background and context and explain what we have completed (front end).</li>
<li>3 minutes - Code architecture description (UML diagram and explaining why we made sure to practice modular programming)</li>
<li>5 minutes - Walk through code on a higher level.</li>
<li>10 minutes - Have everyone clone our repository, run AztexRunner.py with an input of a text file written in our aztex language. This will help the audience gain a better understanding of our program and will also help us to see if our code does not work given any certain inputs. Since people will be inputting a text file that they create, they might create and test a certain input that we had not already tested. This will help us see possible edge cases that we may have overlooked. </li>
<li>3 minutes - Key questions</li>
</ul>

<h2>
<a id="feedback-and-decisions-1" class="anchor" href="#feedback-and-decisions-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Feedback and decisions</h2>

<p>The feedback we received mainly had to do with errors found in tokenizing our code and including other features. We also received a lot of feedback about whether or not we should use a library to generate LaTeX output. Not using the library might be a good idea since we already know how to write code in python, but we do not yet know how to efficiently implement this library into our code. From the feedback, we have also learned that we definitely should provide the user with the actual LaTeX code (not just the final pdf) in case they want to edit the LaTeX document themselves in order to add more customization to their pdf than aztex can allow. Furthermore, if we complete our MVP and still have time to spare, working on a GUI that users can chose to use would be nice. </p>

<p>Also we heard that we should include the following features:</p>

<ul>
<li>list with subelements (DONE) </li>
<li>list with sublists or indents </li>
<li>add argument for file name </li>
<li>one item list </li>
<li>nested elements (bold italicized things) </li>
<li>equations -&gt; tables (DONE) </li>
<li>check if library supports all things </li>
<li>if we write to a tex file people can learn latex </li>
<li>add test suite of example files </li>
<li>gui with equation buttons and side by side would be nice</li>
</ul>

<h3>
<a id="review-process-reflection-1" class="anchor" href="#review-process-reflection-1" aria-hidden="true"><span class="octicon octicon-link"></span></a>Review process reflection</h3>

<p>The review went well. We were able to follow our agenda, and we did get answers to our key questions, especially in regards to our question about if any of our features do not work or what other features we should include. Although we provided a lot of background context about how compilers work and are built, we probably should have provided an example to show people how to use our program. Although people eventually figured out what our program was supposed to output, some people were confused about what the output of our program was supposed to look like (apparently we did not clearly explain that the output was not supposed to be a nice looking pdf document). As a result, the actual process of getting people to test our code went differently than expected. We probably would have been able to get more feedback/test cases if they had more information on what to type and what the output was. Considering that this was also a code review, we probably should come in with more questions and content on actual coding decisions in the future.  </p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/thuctran289/aztex">aztex</a> is maintained by <a href="https://github.com/thuctran289">thuctran289</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>

